// Generated by CoffeeScript 2.0.0
var TestCase;

TestCase = require("./test-base");

//###############################################################################
// Object Macro Tests
//###############################################################################
exports.test_js_objects = async function(test) {
  var bot;
  bot = new TestCase(test, "> object nolang\n    return \"Test w/o language.\"\n< object\n\n> object wlang javascript\n    return \"Test w/ language.\"\n< object\n\n> object reverse javascript\n    var msg = args.join(\" \");\n    return msg.split(\"\").reverse().join(\"\");\n< object\n\n> object broken javascript\n    return \"syntax error\n< object\n\n> object foreign perl\n    return \"Perl checking in!\"\n< object\n\n+ test nolang\n- Nolang: <call>nolang</call>\n\n+ test wlang\n- Wlang: <call>wlang</call>\n\n+ reverse *\n- <call>reverse <star></call>\n\n+ test broken\n- Broken: <call>broken</call>\n\n+ test fake\n- Fake: <call>fake</call>\n\n+ test perl\n- Perl: <call>foreign</call>");
  await bot.reply("Test nolang", "Nolang: Test w/o language.");
  await bot.reply("Test wlang", "Wlang: Test w/ language.");
  await bot.reply("Reverse hello world.", "dlrow olleh");
  await bot.reply("Test broken", "Broken: [ERR: Object Not Found]");
  await bot.reply("Test fake", "Fake: [ERR: Object Not Found]");
  await bot.reply("Test perl", "Perl: [ERR: Object Not Found]");
  return test.done();
};

exports.test_disabled_js_language = async function(test) {
  var bot;
  bot = new TestCase(test, "> object test javascript\n    return 'JavaScript here!'\n< object\n\n+ test\n- Result: <call>test</call>");
  await bot.reply("test", "Result: JavaScript here!");
  bot.rs.setHandler("javascript", void 0);
  await bot.reply("test", "Result: [ERR: No Object Handler]");
  return test.done();
};

exports.test_get_variable = async function(test) {
  var bot;
  bot = new TestCase(test, "! var test_var = test\n\n> object test_get_var javascript\n    var name  = \"test_var\";\n    return rs.getVariable(name);\n< object\n\n+ show me var\n- <call> test_get_var </call>");
  await bot.reply("show me var", "test");
  return test.done();
};

exports.test_uppercase_call = async function(test) {
  var bot;
  bot = new TestCase(test, "> begin\n    + request\n    * <bot mood> == happy => {sentence}{ok}{/sentence}\n    * <bot mood> == angry => {uppercase}{ok}{/uppercase}\n    * <bot mood> == sad   => {lowercase}{ok}{/lowercase}\n    - {ok}\n< begin\n\n> object test javascript\n    return \"The object result.\";\n< object\n\n// Not much we can do about this part right now... when uppercasing the\n// whole reply the name of the macro is also uppercased. *shrug*\n> object TEST javascript\n    return \"The object result.\";\n< object\n\n+ *\n- Hello there. <call>test <star></call>");
  await bot.reply("hello", "Hello there. The object result.");
  bot.rs.setVariable("mood", "happy");
  await bot.reply("hello", "Hello there. The object result.");
  bot.rs.setVariable("mood", "angry");
  await bot.reply("hello", "HELLO THERE. THE OBJECT RESULT.");
  bot.rs.setVariable("mood", "sad");
  await bot.reply("hello", "hello there. the object result.");
  return test.done();
};

exports.test_objects_in_conditions = async function(test) {
  var bot;
  bot = new TestCase(test, "// Normal synchronous object that returns an immediate response.\n> object test_condition javascript\n  return args[0] === \"1\" ? \"true\" : \"false\";\n< object\n\n// Asynchronous object that returns a promise. This isn't supported\n// in a conditional due to the immediate/urgent nature of the result.\n> object test_async_condition javascript\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      resolve(args[0] === \"1\" ? \"true\" : \"false\");\n    }, 10);\n  });\n< object\n\n+ test sync *\n* <call>test_condition <star></call> == true  => True.\n* <call>test_condition <star></call> == false => False.\n- Call failed.\n\n+ test async *\n* <call>test_async_condition <star></call> == true  => True.\n* <call>test_async_condition <star></call> == false => False.\n- Call failed.\n\n+ call sync *\n- Result: <call>test_condition <star></call>\n\n+ call async *\n- Result: <call>test_async_condition <star></call>");
  // First, make sure the sync object works.
  await bot.reply("call sync 1", "Result: true");
  await bot.reply("call sync 0", "Result: false");
  await bot.reply("call async 1", "Result: true");
  // Test the synchronous object in a conditional.
  await bot.reply("test sync 1", "True.");
  await bot.reply("test sync 2", "False.");
  await bot.reply("test sync 0", "False.");
  await bot.reply("test sync x", "False.");
  // Test the async object on its own and then in a conditional. This code looks
  // ugly, but `test.done()` must be called only when all tests have resolved
  // so we have to nest a couple of the promise-based tests this way.
  return bot.rs.reply(bot.username, "call async 1").then(function(reply) {
    test.equal(reply, "Result: true");
    return bot.rs.reply(bot.username, "test async 1").then(function(reply) {
      test.equal(reply, "True.");
      return test.done();
    });
  });
};

exports.test_line_breaks_in_call = async function(test) {
  var bot;
  bot = new TestCase(test, "> object macro javascript\n  var a = args.join(\"; \");\n  return a;\n< object\n\n// Variables with newlines aren't expected to interpolate, because\n// tag processing only happens in one phase.\n! var name = name with\\nnew line\n\n+ test literal newline\n- <call>macro \"argumentwith\\nnewline\"</call>\n\n+ test botvar newline\n- <call>macro \"<bot name>\"</call>");
  await bot.reply("test literal newline", "argumentwith\nnewline");
  await bot.reply("test botvar newline", "name with\\nnew line");
  return test.done();
};

exports.test_js_string_in_setSubroutine = async function(test) {
  var bot, input;
  bot = new TestCase(test, "+ hello\n- hello <call>helper <star></call>");
  input = "hello there";
  bot.rs.setSubroutine("helper", ["return 'person';"]);
  await bot.reply("hello", "hello person");
  return test.done();
};

exports.test_function_in_setSubroutine = async function(test) {
  var bot, input;
  bot = new TestCase(test, "+ my name is *\n- hello person<call>helper <star></call>");
  input = "my name is Rive";
  bot.rs.setSubroutine("helper", function(rs, args) {
    test.equal(rs, bot.rs);
    test.equal(args.length, 1);
    test.equal(args[0], "rive");
    return test.done();
  });
  return (await bot.reply(input, "hello person"));
};

exports.test_function_in_setSubroutine_return_value = async function(test) {
  var bot;
  bot = new TestCase(test, "+ hello\n- hello <call>helper <star></call>");
  bot.rs.setSubroutine("helper", function(rs, args) {
    return "person";
  });
  await bot.reply("hello", "hello person");
  return test.done();
};

exports.test_arguments_in_setSubroutine = async function(test) {
  var bot;
  bot = new TestCase(test, "+ my name is *\n- hello <call>helper \"<star>\" 12</call>");
  bot.rs.setSubroutine("helper", function(rs, args) {
    test.equal(args.length, 2);
    test.equal(args[0], "thomas edison");
    test.equal(args[1], "12");
    return args[0];
  });
  await bot.reply("my name is thomas edison", "hello thomas edison");
  return test.done();
};

exports.test_quoted_strings_arguments_in_setSubroutine = async function(test) {
  var bot;
  bot = new TestCase(test, "+ my name is *\n- hello <call>helper \"<star>\" 12 \"another param\"</call>");
  bot.rs.setSubroutine("helper", function(rs, args) {
    test.equal(args.length, 3);
    test.equal(args[0], "thomas edison");
    test.equal(args[1], "12");
    test.equal(args[2], "another param");
    return args[0];
  });
  await bot.reply("my name is thomas edison", "hello thomas edison");
  return test.done();
};

exports.test_arguments_with_funky_spacing_in_setSubroutine = async function(test) {
  var bot;
  bot = new TestCase(test, "+ my name is *\n- hello <call> helper \"<star>\"   12   \"another  param\" </call>");
  bot.rs.setSubroutine("helper", function(rs, args) {
    test.equal(args.length, 3);
    test.equal(args[0], "thomas edison");
    test.equal(args[1], "12");
    test.equal(args[2], "another  param");
    return args[0];
  });
  await bot.reply("my name is thomas edison", "hello thomas edison");
  return test.done();
};

exports.test_promises_in_objects = function(test) {
  var bot, input;
  bot = new TestCase(test, "+ my name is *\n- hello there <call>helperWithPromise <star></call> with a <call>anotherHelperWithPromise</call>");
  input = "my name is Rive";
  bot.rs.setSubroutine("helperWithPromise", function(rs, args) {
    return new rs.Promise(function(resolve, reject) {
      return resolve("stranger");
    });
  });
  bot.rs.setSubroutine("anotherHelperWithPromise", function(rs) {
    return new rs.Promise(function(resolve, reject) {
      return setTimeout(function() {
        return resolve("delay");
      }, 10);
    });
  });
  return bot.rs.reply(bot.username, input).then(function(reply) {
    test.equal(reply, "hello there stranger with a delay");
    return test.done();
  });
};

exports.test_use_reply_with_async_subroutines = async function(test) {
  var bot;
  bot = new TestCase(test, "+ my name is *\n- hello there <call>asyncHelper</call>");
  bot.rs.setSubroutine("asyncHelper", function(rs, args) {
    return new rs.Promise(function(resolve, reject) {
      return resolve("stranger");
    });
  });
  await bot.reply("my name is Rive", "hello there stranger");
  return test.done();
};

exports.test_async_and_sync_subroutines_together = function(test) {
  var bot;
  bot = new TestCase(test, "+ my name is *\n- hello there <call>asyncHelper</call><call>exclaim</call>");
  bot.rs.setSubroutine("exclaim", function(rs, args) {
    return "!";
  });
  bot.rs.setSubroutine("asyncHelper", function(rs, args) {
    return new rs.Promise(function(resolve, reject) {
      return resolve("stranger");
    });
  });
  return bot.rs.reply(bot.username, "my name is Rive").then(function(reply) {
    test.equal(reply, "hello there stranger!");
    return test.done();
  });
};

exports.test_stringify_with_objects = function(test) {
  var bot, expect, src;
  bot = new TestCase(test, "> object hello javascript\n  return \"Hello\";\n< object\n+ my name is *\n- hello there<call>exclaim</call>\n^ and i like continues");
  bot.rs.setSubroutine("exclaim", function(rs) {
    return "!";
  });
  src = bot.rs.stringify();
  expect = '! version = 2.0\n! local concat = none\n\n> object hello javascript\n\treturn "Hello";\n< object\n\n> object exclaim javascript\n\treturn "!";\n< object\n\n+ my name is *\n- hello there<call>exclaim</call>and i like continues\n';
  test.equal(src, expect);
  return test.done();
};
